[Отчёт 6 лаба.md](https://github.com/user-attachments/files/23841477/6.md)
# Андреева Любовь ИТ-7 Лабораторная №6

# Задание 1
## Задача 1
### Текст задачи
@Invoke.
Разработайте аннотацию @Invoke, со следующими характеристиками:
• Целью может быть только МЕТОД
• Доступна во время исполнения программы
• Не имеет свойств
Создайте класс, содержащий несколько методов, и проаннотируйте хотя бы один из них
аннотацией @Invoke.
Реализуйте обработчик (через Reflection API), который находит методы, отмеченные
аннотацией @Invoke, и вызывает их автоматически.
### Алгоритм решения
1. Создать аннотацию @Invoke
Указать, что цель аннотации — метод.
Установить время жизни — runtime.
Не добавлять никаких свойств.
2. Создать класс с методами
Добавить несколько обычных методов.
Один или несколько методов пометить аннотацией @Invoke.
3. Создать обработчик аннотации
Принять объект для анализа.
Получить все методы его класса через Reflection.
Перебрать методы:
если метод помечен @Invoke → вызвать его через invoke().
Обработать возможные ошибки вызова.
### Тест
<img width="265" height="97" alt="image" src="https://github.com/user-attachments/assets/780eb8c5-9226-4b00-9056-a35afe22fcae" />


## Задача 2
### Текст задачи
@Default.
Разработайте аннотацию @Default, со следующими характеристиками:
• Целью может быть ТИП или ПОЛЕ
• Доступна во время исполнения программы
• Имеет обязательное свойство value типа Class
Проаннотируйте какой-либо класс данной аннотацией, указав тип по умолчанию.
Напишите обработчик, который выводит имя указанного класса по умолчанию.
### Алгоритм решения
1. Создать аннотацию @Default
Указать цели: тип и поле.
Установить время жизни — runtime.
Создать обязательное свойство value типа Class.
2. Создать класс и пометить его @Default
Передать в аннотацию какой-либо класс в качестве значения по умолчанию.
3. Создать обработчик
Проверить, имеет ли класс аннотацию @Default.
Если да → получить значение value() и вывести имя класса.
Если нет → вывести сообщение об отсутствии аннотации.
### Тест
<img width="391" height="76" alt="image" src="https://github.com/user-attachments/assets/a740bff3-f45d-4446-b47a-72cbe80c37af" />


## Задача 3
### Текст задачи
@ToString.
Разработайте аннотацию @ToString, со следующими характеристиками:
• Целью может быть ТИП или ПОЛЕ
• Доступна во время исполнения программы
• Имеет необязательное свойство valuec двумя вариантами значений: YES или NO
• Значение свойства по умолчанию: YES
Проаннотируйте класс аннотацией @ToString, а одно из полей – с @ToString(Mode.NO).
Создайте метод, который формирует строковое представление объекта, учитывая только те поля,
где @ToString имеет значение YES.
### Алгоритм решения
1. Создать аннотацию @ToString
Указать цели: тип и поле.
Установить время жизни — runtime.
Создать перечисление Mode с вариантами YES и NO.
Создать свойство value с режимом Mode.YES по умолчанию.
2. Создать класс
Пометить весь класс @ToString.
Несколько полей оставить без аннотации (они считаются YES).
Одно поле пометить @ToString(Mode.NO).
3. Создать обработчик (метод buildString)
Если на классе нет @ToString — вернуть обычный toString().
Иначе:
Получить все поля.
Для каждого поля:
если нет аннотации или аннотация = YES → включить поле в строку;
если Mode.NO → пропустить.
Сформировать строку вида:
ClassName{field=value; ...}
### Тест
<img width="306" height="73" alt="image" src="https://github.com/user-attachments/assets/65019997-aedd-43eb-8dc8-1b974deda461" />


## Задача 4
### Текст задачи
@Validate.
Разработайте аннотацию @Validate, со следующими характеристиками:
• Целью может быть ТИП или АННОТАЦИЯ
• Доступна во время исполнения программы
• Имеет обязательное свойство value, типа Class[]
Проаннотируйте класс аннотацией @Validate, передав список типов для проверки.
Реализуйте обработчик, который выводит, какие классы указаны в аннотации.
### Алгоритм решения
1. Создать аннотацию @Validate
Цели: тип и аннотация.
Установить время жизни — runtime.
Создать обязательное свойство value типа Class[].
2. Проаннотировать класс @Validate
Передать в аннотацию массив классов.
3. Создать обработчик
Проверить наличие аннотации у класса.
Если аннотация есть → получить массив классов и вывести их имена.
Если нет → вывести сообщение об отсутствии аннотации.
### Тест
<img width="340" height="93" alt="image" src="https://github.com/user-attachments/assets/4ebd809c-336f-4917-ad57-0b359626de75" />


## Задача 5
### Текст задачи
@Two.
Разработайте аннотацию @Two, со следующими характеристиками:
• Целью может быть ТИП
• Доступна во время исполнения программы
• Имеет два обязательных свойства: first типа String и second типа int
Проаннотируйте какой-либо класс аннотацией @Two, передав строковое и числовое значения.
Реализуйте обработчик, который считывает и выводит значения этих свойств.
### Алгоритм решения
1. Создать аннотацию @Two
Указать цель: тип.
Установить время жизни — runtime.
Создать два обязательных свойства:
first — String
second — int
2. Проаннотировать класс @Two
Указать строку и число.
3. Создать обработчик
Проверить, есть ли у класса @Two.
Если есть → получить свойства first и second и вывести их.
Если нет → вывести сообщение.
### Тест
<img width="204" height="92" alt="image" src="https://github.com/user-attachments/assets/c3add50a-7326-4d7e-9325-4dd96707a901" />


## Задача 6
### Текст задачи
@Cache.
Разработайте аннотацию @Cache, со следующими характеристиками:
• Целью может быть ТИП
• Доступна во время исполнения программы
• Имеет необязательное свойство value, типа String[]
• Значение свойства по умолчанию: пустой массив
Проаннотируйте класс аннотацией @Cache, указав несколько кешируемых областей.
Создайте обработчик, который выводит список всех кешируемых областей или сообщение, что
список пуст.
### Алгоритм решения
1. Создать аннотацию @Cache
Цель: тип.
Время жизни: runtime.
Создать свойство value типа String[] с дефолтным значением пустого массива.
2. Проаннотировать класс
Передать несколько строковых значений — названия кешируемых областей.
3. Создать обработчик
Проверить наличие аннотации у класса.
Получить массив областей.
Если массив пуст → вывести сообщение «список пуст».
Иначе → вывести каждую область.
### Тест
<img width="308" height="116" alt="image" src="https://github.com/user-attachments/assets/b3778db2-e717-463a-9d1a-66e877ecda0d" />


# Задание 2
## Задача 1
### Текст задачи
Напишите тест, используя фреймворк JUnit, к методу toString() (или методу, формирующему
строковое представление объекта, основанное на аннотации @ToString).
• Проверить, что в результирующей строке отображаются только те поля, которые имеют
аннотацию @ToString(Mode.YES) или не аннотированы вовсе.
• Убедиться, что поля с @ToString(Mode.NO) не попадают в вывод.
### Алгоритм решения
1. Создать тестовый объект класса, помеченного @ToString
Инициализировать объект.
2. Вызвать метод buildString
Сохранить полученную строку.
3. Проверить корректность результата
Убедиться, что в строке присутствуют поля с Mode.YES и поля без аннотации.
Убедиться, что поле с Mode.NO отсутствует.
Использовать assertTrue() и assertFalse().

## Задача 7
### Текст задачи
Создайте тест, используя фреймворк JUnit, проверяющий совместную работу
аннотаций @Cache и @Invoke на одном классе.
• Разработайте класс, содержащий аннотацию @Cache({"users", "orders"}) и метод,
помеченный @Invoke.
• В тесте c помощью Reflection получите экземпляр аннотированного класса, убедитесь, что
аннотация @Cache корректно возвращает массив строк ["users", "orders"], автоматически
вызовите метод с @Invoke и проверьте, что он действительно выполняется.
• Добавьте проверку, что при пустом массиве @Cache кеширование не активируется
(например, метод не добавляет данные в фиктивный кеш).
• Для моделирования кеша можно использовать Mockito или простую
коллекцию Map<String, Object>.
### Алгоритм решения
1. Получить класс, аннотированный @Cache и содержащий метод @Invoke
Через Reflection получить объект Class.
2. Проверить корректность аннотации @Cache
Получить значение свойства value().
Проверить, что оно равно ["users", "orders"].
3. Создать экземпляр класса через Reflection
Вызвать конструктор.
4. Найти и вызвать метод с @Invoke
Перебрать методы.
Метод с аннотацией @Invoke вызвать через invoke().
Проверить, что флаг выполнения изменился (например, поле invoked = true).
6. Проверка поведения при пустом @Cache
Создать локальный класс, помеченный @Cache({}).
Проверить, что массив пустой.
Создать фиктивный кеш (Map или Mockito).
Убедиться, что ничего не добавилось в кеш при пустом массиве.
### Тесты
<img width="509" height="171" alt="image" src="https://github.com/user-attachments/assets/5b97367f-1165-40d3-b8cf-1a6d50ba644e" />
